RE_ID_TV = Regex('iplayer/tv/([^/]+)/watchlive')
RE_ID_RADIO = Regex('iplayer/radio/([^/]+)/listenlive')
NAMESPACES = {'m': 'http://bbc.co.uk/2008/mp/mediaselection'}

TV_CHANNEL_LOOKUP = {
  "bbc_one_london": "bbc_one",
  "bbc_two_england": "bbc_two",
  "bbc_three": "bbc_three",
  "bbc_four": "bbc_four",
  "cbbc": "cbbc",
  "cbeebies": "cbeebies_1",
  "bbc_news24": "bbc_news24",
  "bbc_parliament": "bbc_parliament_1",
  "bbc_alba": "bbc_alba"
}

RADIO_CHANNEL_LOOKUP = {
  "bbc_radio_one": "bbc_radio_one",  
  "bbc_1xtra": "bbc_1xtra",
  "bbc_radio_two": "bbc_radio_two",
  "bbc_radio_three": "bbc_radio_three",
  "bbc_radio_fourfm": "bbc_radio_four",
  "bbc_radio_fourlw": "bbc_radio_four",
  "bbc_radio_four_extra": "bbc_radio_four",
  "bbc_radio_five_live": "bbc_radio_five_live",
  "bbc_radio_five_live_sports_extra": "bbc_radio_five_live_sports_extra",
  "bbc_6music": "bbc_6music",
  "bbc_asian_network": "bbc_asian_network",
  "bbc_world_service": "bbc_world_service"  
}

####################################################################################################
def NormalizeURL(url):

  return url

####################################################################################################
def MetadataObjectForURL(url):

  page = HTML.ElementFromURL(url)
  on_air = page.xpath('//div[@id = "currently-on-air"]')[0]

  title = on_air.xpath('.//h2[@class = "title"]/text()')[0]

  summary = on_air.xpath('.//div[contains(@class, "long-synopsis")]//text()')[0]
  if summary.endswith('('):
    summary = summary.rstrip('(').strip()

  thumb = None
  match = RE_ID_TV.findall(url)
  if match:
    id = match[0] 
    thumb = "http://www.bbc.co.uk/iplayer/img/tv/%s.jpg" % TV_CHANNEL_LOOKUP[id]
  else:
    match = RE_ID_RADIO.findall(url)
    if match:
      id = match[0]
      thumb = "http://www.bbc.co.uk/iplayer/img/radio/%s.gif" % RADIO_CHANNEL_LOOKUP[id]   

  return VideoClipObject(
    title = title,
    summary = summary,
    thumb = thumb)

####################################################################################################
def MediaObjectsForURL(url):

  return [
    MediaObject(
      protocol = 'rtmp',
      video_resolution = '720',
      audio_channels = 2,
      parts = [PartObject(key=Callback(DetermineAvailableVideo, url = url, height = '720'))],
    ),
    MediaObject(
      protocol = 'rtmp',
      video_resolution = '468',
      audio_channels = 2,
      parts = [PartObject(key=Callback(DetermineAvailableVideo, url = url, height = '468'))],
    ),
    MediaObject(
      protocol = 'rtmp',
      video_resolution = 'sd',
      audio_channels = 2,
      parts = [PartObject(key=Callback(DetermineAvailableVideo, url = url, height = '360'))],
    )
  ]

####################################################################################################

@indirect
def DetermineAvailableVideo(url, height):

  try:
    id = RE_ID_TV.findall(url)[0]
    media_selector_url = "http://www.bbc.co.uk/mediaselector/4/mtis/stream/%s" % id
    return IndirectResponse(VideoClipObject, key = Callback(PlayVideo, url = url, media_selector_url = media_selector_url, height = height, post_url = media_selector_url))

  except:
    # Just in case there is a problem obtaining the RTMP details, we'll fallback to the older WebKit implementation.
    Log.Exception("Error obtaining RTMP details, falling back to WebKit")
    return IndirectResponse(VideoClipObject, key = WebVideoURL(url)) 

####################################################################################################
@indirect
def PlayVideo(url, media_selector_url=None, height='720'):

  try:
    # Make PlayVideo function backwards compatible
    if not media_selector_url:
      raise

    stream_details = XML.ElementFromURL(media_selector_url)

    last_stream = None
    heights = ['720', '468', '360']
    index = heights.index(height)
    for height_index in range(index, len(heights)):
      streams = stream_details.xpath('//m:media[@kind = "video" and @height = "%s"]/m:connection[@protocol = "rtmp"]' % heights[height_index], namespaces = NAMESPACES)
      if len(streams) > 0:

        stream = None
        for potential_stream in streams:
          # Give preference to akamai streams
          if potential_stream.get('supplier') == 'akamai':
            stream = potential_stream
            break

        if stream == None:
          stream = streams[0]
        Log("Stream: " + heights[height_index])
        break
    
    server = stream.get('server')
    auth = stream.get('authString')

    supplier = stream.get('supplier')
    application = stream.get('application')
    if application is None and supplier == 'akamai':
      application = 'ondemand'

    rtmp_url = 'rtmp://%s/%s?%s' % (server, application, auth)

    clip = "%s?%s" % (stream.get('identifier'), auth)
    swf_url = 'http://www.bbc.co.uk/emp/releases/iplayer/revisions/617463_618125_4/617463_618125_4_emp.swf'
    return IndirectResponse(VideoClipObject, key = RTMPVideoURL(url = rtmp_url, clip = clip, swf_url = swf_url, live = True))

  except:
    # Just in case there is a problem obtaining the RTMP details, we'll fallback to the older WebKit implementation.
    Log.Exception("Error obtaining RTMP details, falling back to WebKit")
    return IndirectResponse(VideoClipObject, key = WebVideoURL(url)) 
