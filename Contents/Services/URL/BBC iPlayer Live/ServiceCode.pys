RE_CHANNEL = Regex('iplayer/live/([^/]+)')

TV_CHANNEL_LOOKUP = {
    "bbcone": {"live_id" : "bbc1", "hd_live_id": "bbc_one_hd"},
    "bbctwo": {"live_id" : "bbc2", "hd_live_id": "bbc_two_hd"},
    "bbcthree": {"live_id" : "bbc3", "hd_live_id": "bbc_three_hd"},
    "bbcfour": {"live_id" : "bbc4"},
    "cbbc": {"live_id" : "cbbc"},
    "cbeebies": {"live_id" : "cbeebies"},
    "bbcnews": {"live_id" : "news_ch"},
    "bbcparliament": {"live_id" : "parliament"},
    "bbcalba": {"live_id" : "alba"}
}

NAMESPACES = {'m': 'http://ns.adobe.com/f4m/2.0'}

##########################################################################################
def NormalizeURL(url):
    return url

##########################################################################################
def MetadataObjectForURL(url):
    element = HTML.ElementFromURL(url, cacheTime = 0)

    for on_air_info in element.xpath("//*[@id = 'nownext']//*[@id = 'now']"):
        try:
            pid = on_air_info.xpath(".//a/@href")[0].split("/")[-1]
        except:
            pid = None
        
        if pid:
            try:
                mdo = URLService.MetadataObjectForURL('http://www.bbc.co.uk/iplayer/episode/%s' % pid)
                title = "Live: " + mdo.title
                
                if mdo.index:
                    return EpisodeObject(
                        title = title,
                        thumb = mdo.thumb,
                        summary = mdo.summary,
                        art = mdo.art,
                        originally_available_at = mdo.originally_available_at,
                        duration = mdo.duration,
                        show = mdo.show,
                        season = mdo.season,
                        index = mdo.index
                        
                    )
                else:
                    return VideoClipObject(
                        title = title,
                        thumb = mdo.thumb,
                        summary = mdo.summary,
                        art = mdo.art,
                        originally_available_at = mdo.originally_available_at,
                        duration = mdo.duration
                    )
            except:
                # Fallback to scraping
                pass
        
        # Not a recorded program, use scraping
        try:
            title = 'Live: ' + ''.join(on_air_info.xpath(".//h2/text()")).strip()
        except:
            title = 'Live'

        try:
            time_info = on_air_info.xpath(".//*[@class = 'broadcast-time']//text()")[0].strip()
        except:
            time_info = ''
            
        try:
            subtitle = on_air_info.xpath(".//*[contains(@class = 'subtitle')]//text()")[0].strip()
        except:
            subtitle = ''
     
        try:
            description = on_air_info.xpath('.//*[contains(@class, "synopsis")]//text()')[0].strip()
        except:
            description = ''

        summary = time_info + '\r\n' + subtitle + '\r\n' + description

        try:
            thumb = element.xpath("//*[@id='player-outer']//img/@src")[0]
        except:
            thumb = None
    
        return VideoClipObject(
            title = title,
            summary = summary,
            thumb = thumb
        )   
        
    return Ex.LiveMediaNotStarted

##########################################################################################
def MediaObjectsForURL(url):
    match = RE_CHANNEL.search(url)
    if match:
        channel = match.groups()[0]
        
        video_resolutions = [504]
        
        if 'hd_live_id' in TV_CHANNEL_LOOKUP[channel]:
            video_resolutions.insert(0, 720) 
        
        return [
            MediaObject(
                parts = [
                    PartObject(
                        key = HTTPLiveStreamURL(Callback(PlayVideo, channel = channel, video_resolution = video_resolution))
                    )
                ],
                video_resolution = video_resolution,
                audio_channels = 2,
                optimized_for_streaming = True
            ) for video_resolution in video_resolutions
        ]

##########################################################################################
@indirect
def PlayVideo(channel, video_resolution):

    live_id = TV_CHANNEL_LOOKUP[channel]["live_id"]
    base = String.Decode('aHR0cDovL2EuZmlsZXMuYmJjaS5jby51ay9tZWRpYS9saXZlL21hbmlmZXN0cy9obHMvaGR0di9hay8lcy5tM3U4')
    hls_url = base % live_id
    
    if video_resolution >= 720:
        # Try to find a HD stream
        try:
            live_id = TV_CHANNEL_LOOKUP[channel]["hd_live_id"]
            base = String.Decode('aHR0cDovL3d3dy5iYmMuY28udWsvbWVkaWFzZWxlY3Rvci9wbGF5bGlzdHMvaGRzL3BjL2FrLyVzLmY0bQ==')
            element = XML.ElementFromURL(base % live_id)
            
            highest_bitrate_found = 0
            
            for media in element.xpath("//m:media", namespaces = NAMESPACES):
                bitrate = int(media.get('bitrate'))
                
                if bitrate > highest_bitrate_found:
                    highest_bitrate_found = bitrate
                    hls_url = media.get('href').replace('.f4m', '.m3u8')
        except:
            # Fallback to SD stream
            pass

    try:
        headers = HTTP.Request(hls_url).headers
    except:
        raise Ex.MediaGeoblocked

    # Fix for Plex Web clients(avoid M3U8 cross domain access denied)
    if Client.Product in ['Plex Web'] and Client.Platform not in ['Safari']:
        playlist = HTTP.Request(hls_url).content
        
        for line in playlist.splitlines():
            if line.startswith('http'):
                hls_url = line
                break

    return IndirectResponse(
        VideoClipObject,
        key = HTTPLiveStreamURL(url = hls_url)
    )
