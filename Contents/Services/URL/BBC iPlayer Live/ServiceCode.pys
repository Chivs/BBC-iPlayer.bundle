RE_CHANNEL = Regex('iplayer/live/([^/]+)')

TV_CHANNEL_LOOKUP = {
    "bbcone": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF80L2xpdmUvYmJjX29uZV9oZC9iYmNfb25lX2hkLmlzbWwvbWFzdGVyLm0zdTg='),
    "bbctwo": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF81L2xpdmUvYmJjX3R3b19oZC9iYmNfdHdvX2hkLmlzbWwvbWFzdGVyLm0zdTg='),
    "bbcthree": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF8xL2xpdmUvYmJjX3RocmVlX2hkL2JiY190aHJlZV9oZC5pc21sL21hc3Rlci5tM3U4'),
    "bbcfour": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF8yL2xpdmUvYmJjX2ZvdXJfaGQvYmJjX2ZvdXJfaGQuaXNtbC9tYXN0ZXIubTN1OA=='),
    "cbbc": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF8xL2xpdmUvY2JiY19oZC9jYmJjX2hkLmlzbWwvbWFzdGVyLm0zdTg='),
    "cbeebies": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF8yL2xpdmUvY2JlZWJpZXNfaGQvY2JlZWJpZXNfaGQuaXNtbC9tYXN0ZXIubTN1OA=='),
    "bbcnews": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF81L2xpdmUvYmJjX25ld3NfY2hhbm5lbF9oZC9iYmNfbmV3c19jaGFubmVsX2hkLmlzbWwvbWFzdGVyLm0zdTg='),
    "bbcparliament": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF8xL2xpdmUvYmJjX3BhcmxpYW1lbnQvYmJjX3BhcmxpYW1lbnQuaXNtbC9tYXN0ZXIubTN1OA=='),
    "bbcalba": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF8xL2xpdmUvYmJjX2FsYmEvYmJjX2FsYmEuaXNtbC9tYXN0ZXIubTN1OA=='),
    "s4c": String.Decode('aHR0cDovL3ZzLWhscy11ay1saXZlLmVkZ2VzdWl0ZS5uZXQvcG9vbF85L2xpdmUvczRjcGJzL3M0Y3Bicy5pc21sL21hc3Rlci5tM3U4')
}

RAW_HLS_CLIENTS = ['Android', 'iOS', 'Roku', 'Safari']

##########################################################################################
def NormalizeURL(url):
    return url

##########################################################################################
def MetadataObjectForURL(url):
    element = HTML.ElementFromURL(url, cacheTime = 0)

    for on_air_info in element.xpath("//*[@id = 'nownext']//*[@id = 'now']"):        
        try:
            title = 'Live: ' + ''.join(on_air_info.xpath(".//h2/text()")).strip()
        except:
            title = 'Live'

        try:
            time_info = on_air_info.xpath(".//*[@class = 'broadcast-time']//text()")[0].strip()
        except:
            time_info = ''
            
        try:
            subtitle = on_air_info.xpath(".//*[contains(@class = 'subtitle')]//text()")[0].strip()
        except:
            subtitle = ''
     
        try:
            description = on_air_info.xpath('.//*[contains(@class, "synopsis")]//text()')[0].strip()
        except:
            description = ''

        summary = time_info + '\r\n' + subtitle + '\r\n' + description

        try:
            thumb = element.xpath("//*[@id='player-outer']//img/@src")[0]
        except:
            thumb = None
    
        return VideoClipObject(
            title = title,
            summary = summary,
            thumb = thumb
        )   
        
    return Ex.LiveMediaNotStarted

##########################################################################################
def MediaObjectsForURL(url):
    match = RE_CHANNEL.search(url)
    if match:
        channel = match.groups()[0]
        video_resolutions = [720, 576, 504, 396, 360, 288, 252, 216, 144, 108]
        
        if (channel == "bbcparliament") or (channel == "bbcalba") or (channel == "s4c"):
            # Not available in HD
            video_resolutions = [504, 396, 360, 288, 252, 216, 144, 108]
        
        return [
            MediaObject(
                parts = [
                    PartObject(
                        key = HTTPLiveStreamURL(Callback(PlayVideo, channel = channel, video_resolution = video_resolution))
                    )
                ],
                video_resolution = video_resolution,
                audio_channels = 2,
                optimized_for_streaming = True
            ) for video_resolution in video_resolutions
        ]

##########################################################################################
@indirect
def PlayVideo(channel, video_resolution, **kwargs):

    hls_url = TV_CHANNEL_LOOKUP[channel]

    try:
        streams = GetHLSStreams(hls_url)
    except:
        raise Ex.MediaGeoblocked

    if Client.Platform in RAW_HLS_CLIENTS:
        return IndirectResponse(
            VideoClipObject,
            key = HTTPLiveStreamURL(url = hls_url)
        )        
    else:
        streams = GetHLSStreams(hls_url)
        
        min_resolution_diff = 1000000000 # some huge number to get it started
        hls_url = streams[0]['url']
        
        for stream in streams:
            diff = abs(video_resolution - stream['resolution'])
            if diff < min_resolution_diff:
                min_resolution_diff = diff
                hls_url             = stream['url']

        return IndirectResponse(
            VideoClipObject,
            key = HTTPLiveStreamURL(url = hls_url)
        )  
    
###########################################################
def GetHLSStreams(url):
    streams = []

    playList = HTTP.Request(url).content

    # Parse the m3u8 file to get:
    # - URL
    # - Resolution
    # - Bitrate
    for line in playList.splitlines():
        if "BANDWIDTH" in line:
            stream            = {}
            stream["bitrate"] = int(Regex('(?<=BANDWIDTH=)[0-9]+').search(line).group(0))        

            if "RESOLUTION" in line:
                stream["resolution"] = int(Regex('(?<=RESOLUTION=)[0-9]+x[0-9]+').search(line).group(0).split("x")[1])
            else:
                stream["resolution"] = 0

        elif ".m3u8" in line:
            path = ''
            
            if not line.startswith("http"):
                path = url[ : url.rfind('/') + 1]
                
            stream["url"] = path + line
                    
            streams.append(stream)
                
    sorted_streams = sorted(streams, key = lambda stream: stream["bitrate"], reverse = True)        

    return sorted_streams
